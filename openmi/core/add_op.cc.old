#include "add_op.h"
#include "op_registry.h"
using namespace openmi;

namespace openmi {

void AddOp::Initialize(OpKernelConstruction* ctx) {
  LOG(INFO) << "AddOp::Initialize done";
}

bool IsVector(Tensor& t) {
  auto num_elements_ = t.shape().NumElements();
  auto shapes = t.shape().Shape();
  for (auto dim: shapes) {
    if (num_elements_ / dim == 1 && num_elements_ % dim == 0) {
      return true;
    }
  }
  return false;
}

void AddOp::Compute(OpKernelContext* ctx) {
  Tensor* x1 = nullptr;
  Status status = ctx->session_state()->GetTensor(ctx->inputs()[0], &x1);
  Tensor* x2 = nullptr;
  status = ctx->session_state()->GetTensor(ctx->inputs()[1], &x2);

  TensorShape shape;
  size_t x1_dim_size = x1->shape().Dims();
  size_t x2_dim_size = x2->shape().Dims();
  size_t dim_size = x1_dim_size > x2_dim_size ? x1_dim_size : x2_dim_size;
  for (size_t i = 0; i < dim_size; ++i) {
    uint64_t x1_dim_i = -1L;
    if (i < x1_dim_size) {
      x1_dim_i = x1->shape().DimSize(i);
    }
    uint64_t x2_dim_i = -1L;
    if (i < x2_dim_size) {
      x2_dim_i = x2->shape().DimSize(i);
    }
    shape.AddDim(x1_dim_i > x2_dim_i ? x1_dim_i : x2_dim_i);
  }
  
  Tensor* y = nullptr;
  auto out_name = ctx->name();
  status = ctx->session_state()->GetTensor(out_name, &y);
  if (!y->IsInitialized()) {
    y->set_shape(shape);
    y->Init();
  }

  auto X1 = x1->ToEigenMatrix<float>();
  auto X2 = x2->ToEigenMatrix<float>();
  auto Y = y->ToEigenMatrix<float>();

  Y.noalias() = X1.rowwise() + X2.row(0);
  
  LOG(INFO) << "X1:\n" << X1;
  LOG(INFO) << "X2:\n" << X2; 
  LOG(INFO) << "name:" << out_name << ", Y:\n" << Y << "\nsizeof(tensor::type): " << SizeOfType(y->type());
}

OPENMI_REGISTER_OP_KERNEL(Add, AddOp)
  .Device("CPU");

OPENMI_REGISTER_FILE_TAG(Add);
}
